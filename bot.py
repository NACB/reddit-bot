import praw
import random
import datetime
import time


# FIXME:
# copy your generate_comment function from the madlibs assignment here

madlibs = [
    "[DONNY] is a [PATRIOTIC] [PATRIOT]. There was never any [COLLUSION]. [WE] must show [SUPPORT].",
    "Show [SUPPORT] for [PATRIOTIC] [DONNY]. [PATRIOT]s don't commit [COLLUSION], so don't believe the fake news.",
    "[WE], as [PATRIOT]s need to [SUPPORT] [DONNY]. It is the only way to preserve [AMERICA]s values!",
    "[PATRIOTIC] people know [DONNY] loves [AMERICA]. [SUPPORT] [DONNY]!",
    "[DEMOCRATS] commit [COLLUSION]. [DONNY] doesn't. Bring back [DONNY] for [AMERICA]!",
    "[DONNY] is a [PATRIOT]. [DEMOCRATS] don't have a [PATRIOTIC] bone in their collective bodies. The future of [AMERICA] is [DONNY]!",
    ]

replacements = {
    'DONNY' : ['Donald Trump', 'Donald J Trump', 'Donny T', 'The Donald', 'Trump', 'Bossman T'],
    'PATRIOTIC' : ['patriotic', 'proud', 'loyal', 'nationalistic (but in a good way)'],
    'PATRIOT' : ['patriot', 'PATRIOT', 'American'],
    'COLLUSION' : ['collusion', 'tax fraud', 'quid-pro-quos', 'oafishness', 'the heinous crime of golfing for extended periods of time', 'minor treason'],
    'WE' : ['We', 'Americans'],
    'SUPPORT' : ['support', 'respect', 'love'],
    'AMERICA' : ['America', 'AMERICA', 'the USA', 'our country'],
    'DEMOCRATS' : ['The blue people', 'That party represented by a literal ass', 'The leftists', 'The communists', 'Democrats', 'The AOCs'],
    }

def generate_comment():

    comment = random.choice(madlibs)
    for key in replacements.keys():
        comment = comment.replace("["+key+"]", random.choice(replacements[key]))
    return comment

# FIXME: DONE
# connect to reddit 
reddit = praw.Reddit('bot1')

# FIXME: DONE
# select a "home" submission in the /r/BotTown subreddit to post to,
# and put the url below
submission_url = 'https://old.reddit.com/r/BotTown2/comments/r3i51t/yet_another_anchor_post/?'
submission = reddit.submission(url=submission_url)

# each iteration of this loop will post a single comment;
# since this loop runs forever, your bot will continue posting comments forever;
# (this is what makes it a deamon);
# recall that you can press CTRL-C in the terminal to stop your bot
#
# HINT:
# while you are writing and debugging your code, 
# you probably don't want it to run in an infinite loop;
# you can change this while loop to an if statement to make the code run only once
while True:

    # printing the current time will help make the output messages more informative
    # since things on reddit vary with time
    print()
    print('new iteration at:',datetime.datetime.now())
    print('submission.title=',submission.title)
    print('submission.url=',submission.url)

    # FIXME (task 0): get a list of all of the comments in the submission
    # HINT: this requires using the .list() and the .replace_more() functions
    submission.comments.replace_more(limit=None)
    all_comments = []
    for comment in submission.comments.list():
        all_comments.append(comment)
   
    # HINT: 
    # we need to make sure that our code is working correctly,
    # and you should not move on from one task to the next until you are 100% sure that 
    # the previous task is working;
    # in general, the way to check if a task is working is to print out information 
    # about the results of that task, 
    # and manually inspect that information to ensure it is correct; 
    # in this specific case, you should check the length of the all_comments variable,
    # and manually ensure that the printed length is the same as the length displayed on reddit;
    # if it's not, then there are some comments that you are not correctly identifying,
    # and you need to figure out which comments those are and how to include them.
    print('len(all_comments)=',len(all_comments))
    
    # FIXME (task 1): filter all_comments to remove comments that were generated by your bot
    # HINT: 
    # use a for loop to loop over each comment in all_comments,
    # and an if statement to check whether the comment is authored by you or not
    not_my_comments = []
    for comment in all_comments:
    #    print('comment.author=', comment.author)
    #    print('type comment.author=', type(comment.author))
        if str(comment.author) != 'CSCIbot':
            not_my_comments.append(comment)
    
    # HINT:
    # checking if this code is working is a bit more complicated than in the previous tasks;
    # reddit does not directly provide the number of comments in a submission
    # that were not gerenated by your bot,
    # but you can still check this number manually by subtracting the number
    # of comments you know you've posted from the number above;
    # you can use comments that you post manually while logged into your bot to know 
    # how many comments there should be. 
    print('len(not_my_comments)=',len(not_my_comments))


    # if the length of your all_comments and not_my_comments lists are the same,
    # then that means you have not posted any comments in the current submission;
    # (your bot may have posted comments in other submissions);
    # your bot will behave differently depending on whether it's posted a comment or not
    has_not_commented = len(not_my_comments) == len(all_comments)
    #print('has not commented=', has_not_commented)

    if has_not_commented:
        # FIXME (task 2) DONE
        # if you have not made any comment in the thread, then post a top level comment
        #
        # HINT:
        # use the generate_comment() function to create the text,
        # and the .reply() function to post it to reddit;
        # a top level comment is created when you reply to a post instead of a message
        text = generate_comment()
        try:
            submission.reply(text)
        except praw.exceptions.RedditAPIException as error:
            print('waiting 120s because', error)
            time.sleep(120)
    
########################################################################################################################################################
    else:
        # FIXME (task 3): filter the not_my_comments list to also remove comments that    DONE
        # you've already replied to
        # HINT:
        # there are many ways to accomplish this, but my solution uses two nested for loops
        # the outer for loop loops over not_my_comments,
        # and the inner for loop loops over all the replies of the current comment from the outer loop,
        # and then an if statement checks whether the comment is authored by you or not
        comments_without_replies = []
        for comments in not_my_comments:
            not_replied = True
            for comment in comments.replies:
                if str(comment.author) != 'CSCIbot':
                    not_replied = False
            if not_replied:
                comments_without_replies.append(comments)
        # HINT:
        # this is the most difficult of the tasks,
        # and so you will have to be careful to check that this code is in fact working correctly
        print('len(comments_without_replies)=',len(comments_without_replies))
    
        # FIXME (task 4): randomly select a comment from the comments_without_replies list,
        # and reply to that comment
        #
        # HINT:
        # use the generate_comment() function to create the text,
        # and the .reply() function to post it to reddit;
        # these will not be top-level comments;
        # so they will not be replies to a post but replies to a message

        for comments in comments_without_replies:
            selection = random.choice(comments_without_replies)
            generated_reply = generate_comment()
            try:
                selection.reply(generated_reply)
            except praw.exceptions.APIException as error:
                if "DELETED_COMMENT" in str(error):
                    print('not replying to deleted comment')
                else:
                    pass
            except praw.errors.RateLimitExceeded as error:
                print('waiting, because', error)
                pass
            except praw.exceptions.RedditAPIException:
                print('waiting 120s because', error)
                time.sleep(120)


    # FIXME (task 5): select a new submission for the next iteration;
    # your newly selected submission should be randomly selected from the 5 hottest submissions

    randomnumber = random.random()
    allsubmissions = []
    if randomnumber >= 0.9:
        print('Checking the BotCave for unwanted political opinions...')
        submission = reddit.submission(url='https://old.reddit.com/r/BotTown2/comments/r3i51t/yet_another_anchor_post/?')
        try:
            submission.reply(generate_comment())
        except praw.exceptions.RedditAPIException as error:
            print (error)
            time.sleep(120)
    if randomnumber < 0.9:
        print('Infiltrating Top Subreddits')
        for submission in reddit.subreddit('BotTown2').hot(limit=5):
            allsubmissions.append(submission)
        newsubmission = random.choice(allsubmissions)
        submission = reddit.submission(id=newsubmission)
        print('Submission ID: ', newsubmission)
        print(newsubmission.title)


    # We sleep just for 1 second at the end of the while loop.
    # This doesn't avoid rate limiting
    # (since we're not sleeping for a long period of time),
    # but it does make the program's output more readable.
    time.sleep(1)
